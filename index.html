<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OoT Glitch Docs Index</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { margin: 0 0 8px; }
    .muted { opacity: 0.75; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 16px 0; }
    input[type="search"] { padding: 10px 12px; min-width: 260px; flex: 1; }
    select { padding: 10px 12px; }
    button { padding: 10px 12px; cursor: pointer; }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { text-align: left; padding: 10px 8px; border-bottom: 1px solid rgba(127,127,127,0.25); vertical-align: top; }
    td.editable .editable-wrap { display: flex; align-items: flex-start; gap: 6px; }
    td.editable .cell-content { flex: 1; min-width: 0; }
    td.editable input, td.editable textarea { width: 100%; padding: 6px 8px; font: inherit; box-sizing: border-box; }
    .title-edit { display: grid; gap: 6px; width: 100%; }
    .title-edit-row { display: flex; gap: 6px; }
    .title-edit-row button { padding: 6px 10px; font-size: 12px; }
    .edit-btn { padding: 2px 6px; font-size: 12px; opacity: 0.6; cursor: pointer; border: none; background: transparent; flex-shrink: 0; }
    .edit-btn:hover { opacity: 1; }
    th { position: sticky; top: 0; background: canvas; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid rgba(127,127,127,0.5); border-radius: 999px; margin: 0 6px 6px 0; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12px; }
    .count { margin-left: auto; }
    .error { padding: 10px 12px; border: 1px solid rgba(255,0,0,0.4); border-radius: 8px; }
    a { word-break: break-word; }
  </style>
</head>

<body>
  <h1>OoT Technical Docs Index</h1>
<div class="muted" style="max-width: 900px; line-height: 1.35; margin-bottom: 6px;">
  <div>Notes and explanations about the technical details of glitches / OoT mechanics</div>
  <div id="subtitle"></div>
</div>

  
<section style="margin-top: 22px; max-width: 900px;">
  <h2 style="margin: 0 0 10px;">Submit an entry</h2>
  <form id="submitForm" style="display: grid; gap: 10px;">
    <label style="display: grid; gap: 6px;">
      <span class="muted">Author (optional)</span>
      <input id="s_user" autocomplete="nickname" placeholder="e.g., myusername" />
    </label>

    <label style="display: grid; gap: 6px;">
      <span class="muted">Link to doc (required)</span>
      <input id="s_link" type="url" inputmode="url" autocomplete="url" placeholder="https://…" required />
    </label>

    <label style="display: grid; gap: 6px;">
      <span class="muted">Title (required)</span>
      <input id="s_title" autocomplete="off" placeholder="e.g., Wrong warp explanation..." required />
    </label>

    <label style="display: grid; gap: 6px;">
      <span class="muted">Tags (comma separated)</span>
      <input id="s_tags" autocomplete="off" placeholder="rba, srm, wrong warp" />
    </label>

    <label style="display: grid; gap: 6px;">
      <span class="muted">Notes</span>
      <textarea id="s_notes" rows="2" placeholder="Caveats, descriptions, etc."></textarea>
    </label>

    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 4px;   margin-bottom: 14px;  /* <-- add this */">
      <button id="s_submit" type="button">Submit</button>
      <div id="s_msg" class="muted" aria-live="polite"></div>
    </div>
  </form>
</section>
  <h2 style="margin: 0 0 10px;">Database</h2>

  <div class="row">
    <input id="q" type="search" placeholder="Search title, author, tags, notes…" autocomplete="off" />
    <select id="tagFilter" style="display:none">
  <option value="">All tags</option>
</select>
    <select id="sort">
      <option value="title_asc" selected>Sort: Title (A→Z)</option>
      <option value="title_desc">Sort: Title (Z→A)</option>
    </select>
    <button id="reset">Reset</button>
    <div class="count muted" id="count"></div>
  </div>

  <div id="status"></div>

  <table aria-label="glitch index">
    <thead>
      <tr>
        <th style="width: 20%">Title</th>
        <th style="width: 14%">Author</th>
        <th>Notes</th>
        <th style="width: 20%">Tags</th>
        <th style="width: 14%">Added</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
<script>
  const { createClient } = supabase;
  
  // Put these from Supabase Project Settings → API
  const SUPABASE_URL = "https://oxpfqgsjkmkgtmmrlpoh.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_pXZjZlbNjByPd2CRkq-CUQ_w7O0XQ6p";
  
  const db = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
  const state = {
    raw: [],
    filtered: [],
    tags: new Set(),
    meta: { version: 0, updated_at: "" }
  };

  const els = {
    status: document.getElementById("status"),
    tbody: document.getElementById("tbody"),
    q: document.getElementById("q"),
    tagFilter: document.getElementById("tagFilter"),
    sort: document.getElementById("sort"),
    reset: document.getElementById("reset"),
    count: document.getElementById("count")
  };

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

    // Case-insensitive compare with decent locale handling
  const collator = new Intl.Collator(undefined, { sensitivity: "base" });
  
  // Return true if the first non-space character is 0-9
  function startsWithDigit(s) {
    const t = String(s || "").trim();
    return t.length > 0 && t[0] >= "0" && t[0] <= "9";
  }

  function toDateMs(iso) {
    const t = Date.parse(iso || "");
    return Number.isFinite(t) ? t : 0;
  }

  function normalizeArray(v) {
    if (!v) return [];
    return Array.isArray(v) ? v : [v];
  }

  function pillList(items) {
    const arr = normalizeArray(items).filter(Boolean);
    if (!arr.length) return "";
    return arr.map(x => `<span class="pill">${escapeHtml(x)}</span>`).join("");
  }

  function buildFilters() {
    const tagOptions = [...state.tags].sort((a,b)=>a.localeCompare(b));
    for (const t of tagOptions) {
      const opt = document.createElement("option");
      opt.value = t;
      opt.textContent = t;
      els.tagFilter.appendChild(opt);
    }
  }

function sortItems(items) {
  const mode = els.sort.value;
  const copy = [...items];

  if (mode === "title_asc") {
    copy.sort((a, b) => {
      const aTitle = String(a.title || "");
      const bTitle = String(b.title || "");

      const aIsNum = startsWithDigit(aTitle) ? 1 : 0;
      const bIsNum = startsWithDigit(bTitle) ? 1 : 0;

      // letters first, numbers last
      if (aIsNum !== bIsNum) return aIsNum - bIsNum;

      // within the same bucket, normal alphabetical
      return collator.compare(aTitle, bTitle);
    });
  } else if (mode === "title_desc") {
    copy.sort((a, b) => {
      const aTitle = String(a.title || "");
      const bTitle = String(b.title || "");

      const aIsNum = startsWithDigit(aTitle) ? 1 : 0;
      const bIsNum = startsWithDigit(bTitle) ? 1 : 0;

      // keep the same bucketing rule: letters first, numbers last
      if (aIsNum !== bIsNum) return aIsNum - bIsNum;

      // reverse alphabetical within the bucket
      return collator.compare(bTitle, aTitle);
    });
  } else if (mode === "newest") {
    copy.sort((a,b)=>toDateMs(b.added_at) - toDateMs(a.added_at));
  } else if (mode === "oldest") {
    copy.sort((a,b)=>toDateMs(a.added_at) - toDateMs(b.added_at));
  }
  return copy;
}

  function applyFilters() {
    const q = els.q.value.trim().toLowerCase();
    const tag = els.tagFilter.value;

    const filtered = state.raw.filter(item => {
      const title = String(item.title || "");
      const author = String(item.author || "");
      const url = String(item.url || "");
      const notes = String(item.notes || "");
      const tags = normalizeArray(item.tags);

      if (tag && !tags.includes(tag)) return false;

      if (!q) return true;
      const haystack = [
        title,
        author,
        notes,
        tags.join(" "),
        url
      ].join(" ").toLowerCase();

      return haystack.includes(q);
    });

    state.filtered = sortItems(filtered);
    renderTable();
  }

  function renderTable() {
    els.tbody.innerHTML = "";

    const rows = state.filtered.map(item => {
      const title = escapeHtml(item.title || "(untitled)");
      const url = String(item.url || "");
      const safeUrl = escapeHtml(url);
      const author = escapeHtml(item.author || "");
      const tagsHtml = pillList(item.tags);
      const added = escapeHtml(item.added_at || "");
      const notes = escapeHtml(item.notes || "");
      const id = item.id || "";

      const titleCell = url
        ? `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer"><strong>${title}</strong></a>`
        : `<strong>${title}</strong> <span class="muted">(no url)</span>`;

      const editBtn = (field, label) =>
        `<button type="button" class="edit-btn" data-field="${field}" aria-label="Edit ${label}">✎</button>`;

      return `
        <tr data-id="${escapeHtml(id)}">
          <td class="editable" data-field="title"><div class="editable-wrap"><span class="cell-content">${titleCell}</span>${editBtn("title", "title")}</div></td>
          <td class="editable" data-field="author"><div class="editable-wrap"><span class="cell-content">${author || '<span class="muted">—</span>'}</span>${editBtn("author", "author")}</div></td>
          <td class="editable" data-field="notes"><div class="editable-wrap"><span class="cell-content">${notes || '<span class="muted">—</span>'}</span>${editBtn("notes", "notes")}</div></td>
          <td class="editable" data-field="tags"><div class="editable-wrap"><span class="cell-content">${tagsHtml || '<span class="muted">—</span>'}</span>${editBtn("tags", "tags")}</div></td>
          <td class="mono">${added || '<span class="muted">—</span>'}</td>
        </tr>
      `;
    }).join("");

    els.tbody.innerHTML = rows || `<tr><td colspan="5" class="muted">No results.</td></tr>`;
    els.count.textContent = `${state.filtered.length} / ${state.raw.length}`;
  }

  function startEdit(cell, itemId, field, currentValue) {
    if (field === "title") {
      const currentTitle = String(currentValue?.title || "");
      const currentUrl = String(currentValue?.url || "");
      const wrap = document.createElement("div");
      wrap.className = "title-edit";

      const titleInput = document.createElement("input");
      titleInput.type = "text";
      titleInput.placeholder = "Title";
      titleInput.value = currentTitle;

      const urlInput = document.createElement("input");
      urlInput.type = "url";
      urlInput.placeholder = "https://...";
      urlInput.value = currentUrl;

      const actions = document.createElement("div");
      actions.className = "title-edit-row";

      const saveBtn = document.createElement("button");
      saveBtn.type = "button";
      saveBtn.textContent = "Save";

      const cancelBtn = document.createElement("button");
      cancelBtn.type = "button";
      cancelBtn.textContent = "Cancel";

      actions.appendChild(saveBtn);
      actions.appendChild(cancelBtn);
      wrap.appendChild(titleInput);
      wrap.appendChild(urlInput);
      wrap.appendChild(actions);
      cell.innerHTML = "";
      cell.appendChild(wrap);
      titleInput.focus();
      titleInput.select();

      async function saveTitleEdit() {
        const nextTitle = titleInput.value.trim();
        const nextUrl = urlInput.value.trim();
        if (!nextTitle) return titleInput.focus();
        if (!nextUrl) return urlInput.focus();
        try { new URL(nextUrl); } catch { return urlInput.focus(); }

        if (nextTitle === currentTitle && nextUrl === currentUrl) {
          renderTable();
          return;
        }
        await updateEntry(itemId, { title: nextTitle, url: nextUrl });
      }

      saveBtn.addEventListener("click", saveTitleEdit);
      cancelBtn.addEventListener("click", () => renderTable());
      wrap.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          e.preventDefault();
          renderTable();
        } else if (e.key === "Enter") {
          e.preventDefault();
          saveTitleEdit();
        }
      });
      return;
    }

    const isTags = field === "tags";
    const current = isTags
      ? normalizeArray(currentValue).join(", ")
      : String(currentValue || "");
    const el = document.createElement(isTags ? "input" : "textarea");
    el.type = isTags ? "text" : null;
    el.value = current;
    el.style.minHeight = isTags ? "" : "60px";
    el.style.resize = "vertical";
    cell.innerHTML = "";
    cell.appendChild(el);
    el.focus();
    el.select?.();

    function finishEdit() {
      const newVal = el.value.trim();
      const oldVal = isTags ? normalizeArray(currentValue).join(", ") : String(currentValue || "");
      if (newVal !== oldVal) {
        updateEntry(itemId, { [field]: isTags ? parseTagsCsv(newVal) : newVal });
      } else {
        renderTable();
      }
    }

    el.addEventListener("blur", finishEdit);
    el.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey && !isTags) {
        e.preventDefault();
        el.blur();
      } else if (e.key === "Escape") {
        el.value = current;
        el.blur();
      }
    });
  }

  async function updateEntry(id, updates) {
    const { error } = await db.from("glitches").update(updates).eq("id", id);
    if (error) {
      console.error(error);
      renderTable();
      return;
    }
    const item = state.raw.find((r) => String(r.id) === String(id));
    if (item) Object.assign(item, updates);
    renderTable();
  }

  els.tbody.addEventListener("click", (e) => {
    const btn = e.target.closest("button.edit-btn");
    if (!btn) return;
    e.preventDefault();
    const cell = btn.closest("td.editable");
    if (!cell || cell.querySelector("input, textarea")) return;
    const row = cell.closest("tr");
    const itemId = row?.dataset?.id;
    if (!itemId) return;
    const field = cell.dataset?.field;
    if (!field) return;
    const item = state.raw.find((r) => String(r.id) === itemId) || state.filtered.find((r) => String(r.id) === itemId);
    if (!item) return;
    const currentValue = field === "title"
      ? { title: item.title, url: item.url }
      : item[field];
    startEdit(cell, itemId, field, currentValue);
  });

async function load() {
  try {
    els.status.innerHTML = "";

    const { data, error } = await db
      .from("glitches")
      .select("id,title,author,url,notes,tags,added_at")
      .order("title", { ascending: true });

    if (error) throw error;

    const list = Array.isArray(data) ? data : [];
    state.raw = list;

    // rebuild tags
    state.tags = new Set();
    for (const item of list) {
      for (const t of normalizeArray(item.tags)) if (t) state.tags.add(String(t));
    }

    if (els.subtitle) els.subtitle.textContent = `Loaded from Supabase • ${list.length} entries`;

    // rebuild tag dropdown (clear old options except "All tags")
    els.tagFilter.querySelectorAll("option:not([value=''])").forEach(o => o.remove());
    buildFilters();

    // initial render
    state.filtered = sortItems(state.raw);
    renderTable();
    applyFilters();
  } catch (err) {
    if (els.subtitle) els.subtitle.textContent = "Failed to load index.";
    els.status.innerHTML =
      `<div class="error"><strong>Error:</strong> ${escapeHtml(err.message || String(err))}</div>`;
    console.error(err);
  }
}

  load();

const s = {
  user: document.getElementById("s_user"),
  link: document.getElementById("s_link"),
  title: document.getElementById("s_title"),
  tags: document.getElementById("s_tags"),
  notes: document.getElementById("s_notes"),
  submit: document.getElementById("s_submit"),
  msg: document.getElementById("s_msg"),
};

function parseTagsCsv(s) {
  return String(s || "")
    .split(",")
    .map(t => t.trim())
    .filter(Boolean)
    .slice(0, 25); // tiny sanity limit
}

async function submitEntry() {
  s.msg.textContent = "";

  const author = s.user.value.trim();
  const url = s.link.value.trim();
  const title = s.title.value.trim();
  const notes = s.notes.value.trim();
  const tags = parseTagsCsv(s.tags.value);

  if (!title) return (s.msg.textContent = "Title is required.");
  if (!url) return (s.msg.textContent = "Link is required.");
  try { new URL(url); } catch { return (s.msg.textContent = "Link must be a valid URL (include https://)."); }

  s.submit.disabled = true;
  s.msg.textContent = "Submitting…";

  const { error } = await db.from("glitches").insert([{
    title,
    author: author || null,
    url,
    notes: notes || null,
    tags,
    // added_at will default on the DB, but you can also send:
    // added_at: new Date().toISOString().slice(0,10),
  }]);

  s.submit.disabled = false;

  if (error) {
    console.error(error);
    s.msg.textContent = `Submit failed: ${error.message}`;
    return;
  }

  s.msg.textContent = "Submitted! Refresh to view";

  // Clear inputs
  s.link.value = "";
  s.title.value = "";
  s.notes.value = "";
  s.tags.value = "";

  // Reload from DB so it appears immediately
  await load();
}

s.submit.addEventListener("click", submitEntry);

// Keep table in sync with UI controls
els.q.addEventListener("input", applyFilters);
els.tagFilter.addEventListener("change", applyFilters);
els.sort.addEventListener("change", applyFilters);

els.reset.addEventListener("click", () => {
  els.q.value = "";
  els.tagFilter.value = "";
  els.sort.value = "title_asc";
  applyFilters();
});
  
</script>
</body>
</html>
